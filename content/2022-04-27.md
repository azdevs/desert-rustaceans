+++
title = "An Exploration of wasmcloud Microservices"
date = 2022-04-27
draft = false
in_search_index = true
template = "page.html"

[taxonomies]
tags = ["Rust", "Web"]
categories = ["meetups"]
+++

Topics:

- What's changed in Rust? via [@jacobrosenthal](https://github.com/jacobrosenthal)
- An Exploration of wasmcloud Microservices via [@LJ](https://github.com/louiemontes)

<!-- more -->

# What's changed in Rust? via [@jacobrosenthal](https://github.com/jacobrosenthal)

## Rust Analyzer

[rust-analyzer](https://rust-analyzer.github.io/) continues to get better and provides Rust with a proper IDE experience. If you are using VSCode, it is still not the default Rust extension. Per [the official Rust in Visual Studio Code](https://code.visualstudio.com/docs/languages/rust), the RLS extension will soon be deprecated and rust-analyzer will be the recommended VS Code Rust extension by rust-lang.org. New assists are being added to [the list of features](https://rust-analyzer.github.io/manual.html#features) all the time. Some of the most useful ones are below

- [Hover](https://rust-analyzer.github.io/manual.html#hover): shows you documentation when you hover over an expression.

- [Inlay Hints](https://rust-analyzer.github.io/manual.html#inlay-hints): shows type information for variables and chained expressions, making it easy to know what something is without digging into code. At the [2/24/2021 Meetup](https://rust.azdevs.org/2021-02-24/), we discussed [a cool trick](https://github.com/rust-lang/rust-analyzer/issues/1977#issuecomment-761032664) for toggling Inlay Hints on and off.

## Crates VSCode Plugin

[crates](https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates) is another awesome VSCode plugin for Rust. It helps you manage dependencies by displaying the latest version of a crate next to it in your `Cargo.toml`. It also will show all versions (clickable) on the tooltip of the crate hovered.

# An Exploration of wasmcloud Microservices via [@LJ](https://github.com/louiemontes)

## What is Serverless?

In the old days, you had a server under your desk running your program all the time. Either that, or you were paying someone for a whole server in the cloud (you pay the same price regardless if your using it or not). Later, we had virtualized servers that were multitenant (your sharing with other users which introduces security concerns about people potentially sniffing into your memory).

With serverless architecture, you pay for every request. There is still a server but you are breaking your usage down to the smallest atomic piece possible. Serverless requests are flexible. They can be event-driven, so you can fire a serverless request when a file gets uploaded to an S3 bucket. Serverless functions are also built into cloud provider's identity model, so you can put an API Gateway in front of your serverless functions. There's an overhead to doing this, but it's at least an alternative to running VMs.

## WASM and Serverless Architecture

You don't need WASM to run serverless functions, they make a runtime for most languages we already use. However, wasm provides some benefits. For one time, you have a sandbox to make sure people aren't accessing your memory. [wasmCloud](https://wasmcloud.dev/) and [Cloudflare Workers](https://workers.cloudflare.com/) both use the V8 runtime.

## What is wasmCloud?

wasmCloud is a distributed platform that follows the Actor-Context-Provider pattern. It is a self-repairing network, so you can hotswap providers if one is down.

- [Actors](https://wasmcloud.dev/reference/host-runtime/actors/) are snippets of wasm containing business logic.

- [Providers](https://wasmcloud.dev/reference/host-runtime/capabilities/) are functionality required by the actors that are not part of the core business logic (e.g. an HTTP server).

- [Lattice](https://wasmcloud.dev/reference/lattice/) is the RPC bus between actors and providers which essentially tells actors what providers to use. Not every provider satisfies an actor's needs, which is part of the purpose of the lattice.

## wasmCloud Demo

DEMO STUFF HERE

# RFCs You Should Know

- [multidep](https://rust-lang.github.io/rfcs/3176-cargo-multi-dep-artifacts.html): Allow Cargo packages to depend on the same crate multiple times with different dependency names, to support artifact dependencies for multiple targets. This will make it easier to build a native binary project that depends on one or more wasm crates.
